<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Project 1</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>

  .gridlines line {
    stroke: #bbb;
  }

  .gridlines .domain {
    stroke: none;
  }

</style>
</head>
<body>
    <h1>Pokemon Data Analytics</h1>
    <h2>Max Coleman, Leo Decter, Sam Fuchs</h2>

    <svg class="viz"></svg>

    <svg class="pokemon_type" height = "800" width="800"></svg>

    <script>

    data = d3.csv("data/pokedex.csv", d3.autoType)
    .then(data => {
        console.log("data", data);
        const badSubNames = [
            "Mega ",
            "Alolan",
            "Galarian",
            "Therian Forme",
            "Resolute Forme",
            "Primal ",
            "Ash-"
        ];
        const badNames = [
            //"Alolan",
            //"Galarian",
            "Deoxys Attack Forme",
            "Deoxys Defense Forme",
            "Deoxys Speed Forme",
            "Giratina Origin Forme",
            "Basculin Blue-Striped Form",
            //"Therian Forme",
            "Black Kyurem",
            "White Kyurem",
            //"Resolute Forme",
            "Meowstic Female",
            "Aegislash Shield Forme",
            "Pumpkaboo Small Size",
            "Pumpkaboo Large Size",
            "Pumpkaboo Super Size",
            "Gourgeist Small Size",
            "Gourgeist Large Size",
            "Gourgeist Super Size",
            "Zygarde 50% Forme",
            "Zygarde 10% Forme",
            "Own Tempo Rockruff",
            "Lycanroc Midday Form",
            "Lycanroc Midnight Form",
            "Wishiwashi Solo Form",
            "Minior Meteor Form",
            "Toxtricity Low Key Form",
            "Eiscue Noice Face",
            "Indeedee Male",
            "Morpeko Hangry Mode",
            "Eternatus Eternamax",
            "Partner Eevee",
            "Partner Pikachu"
        ]

        data = data.filter( (d) => {
            let keep = true;
            if (badNames.includes(d.name)) {
              keep = false
            }
            badSubNames.forEach(name => {
              if (d.name.includes(name)) {
                keep = false;
              }
            });
            return keep;
        });



      console.log("data", data);

      function total(generation){
        count = 0
        if (generation === 0){
          data.forEach(d => {
            if (d['name'].includes("Castform")){
              count += 1/4;
            }
            else if (d['name'].includes("Wormadam")){
              count+= 1/3;
            }
            else if (d['name'].includes("Rotom")){
              count += 1/6;
            }
            else if (d['name'].includes("Shaymin")){
              count += 1/2;
            }
            else if (d['name'].includes("Darmanitan")){
              count += 1/2;
            }
            else if (d['name'].includes("Meloetta")){
              count += 1/2;
            }
            else if (d['name'].includes("Hoopa")){
              count += 1/2;
            }
            else if (d['name'].includes("Oricorio")){
              count += 1/4;
            }
            else if (d['name'].includes("Necrozma")){
              count+= 1/4;
            }
            else if (d['name'].includes("Zacian")){
              count +=1/2;
            }
            else if (d['name'].includes("Zamazenta")){
              count += 1/2;
            }
            else {
              count += 1
            }
          })
        }else {
            data.forEach( d => {
              if (d['generation'] === generation) {
                if (d['name'].includes("Castform")){
                  count += 1/4;
                }
                else if (d['name'].includes("Wormadam")){
                  count+= 1/3;
                }
                else if (d['name'].includes("Rotom")){
                  count += 1/6;
                }
                else if (d['name'].includes("Shaymin")){
                  count += 1/2;
                }
                else if (d['name'].includes("Darmanitan")){
                  count += 1/2;
                }
                else if (d['name'].includes("Meloetta")){
                  count += 1/2;
                }
                else if (d['name'].includes("Hoopa")){
                  count += 1/2;
                }
                else if (d['name'].includes("Oricorio")){
                  count += 1/4;
                }
                else if (d['name'].includes("Necrozma")){
                  count+= 1/4;
                }
                else if (d['name'].includes("Zacian")){
                  count +=1/2;
                }
                else if (d['name'].includes("Zamazenta")){
                  count += 1/2;
                }
                else {
                  count += 1
                }
              }
            })
          }
          return count;
        }
        console.log("Total", total(0));
        console.log("gen 1", total(1));
        console.log("gen 2", total(2));
        console.log("gen 3", total(3));
        console.log("gen 4", total(4));
        console.log("gen 5", total(5));
        console.log("gen 6", total(6));
        console.log("gen 7", total(7));
        console.log("gen 8", total(8));
      //})

      const type_color = {'Normal': '#a8a878', 'Fire': '#f08030', 'Fighting': '#c03028',
                          'Water': '#6890f0', 'Flying': '#a890f0', 'Grass': '#78c850',
                          'Poison': '#a040a0', 'Electric': '#f8d030', 'Ground': '#e0c068',
                          'Psychic': '#f85888', 'Rock': '#b8a038', 'Ice': '#98d8d8',
                          'Bug': '#a8b820', 'Dragon': '#7038f8', 'Ghost': '#705898',
                          'Dark': '#705848', 'Steel': '#b8b8d0', 'Fairy': '#ee99ac'}


        // function Total(generation){
        //     count = 0
        //     if (generation == 0) {
        //         data.forEach(d => {
        //             if (d['name'].includes("Castform")) {
        //                 count += 1/4
        //             }
        //         })
        //     }
        // }

        let svg = d3.select("svg.viz")

        const HEIGHT = 800;
        const WIDTH  = 800;
        const margin = {'left':40, 'right':20, 'top':20, 'bottom':40 }
        const CHART_HEIGHT = HEIGHT - (margin.top + margin.bottom)
        const CHART_WIDTH = WIDTH - (margin.left + margin.right)

        let chart = svg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`)

        let x_scale = d3.scaleLinear()
          .domain([0, d3.max(data, d => d.attack)])
          .range([0, CHART_WIDTH])
        let y_scale = d3.scaleLinear()
          .domain([0, d3.max(data, d => d.defense)])
          .range([CHART_HEIGHT, 0])

        let x_axis = d3.axisBottom().scale(x_scale)
        let y_axis = d3.axisLeft().scale(y_scale)
        let axes = chart.append('g')
        axes.append('g').call(x_axis)
            .attr('transform', `translate(0,${CHART_HEIGHT})`);
        axes.append('g').call(y_axis)

        console.log(x_scale.domain())

        let els = chart.selectAll('circle').data(data)
        els.exit().remove()
        els.enter()
            .append('circle')
            .attr('r', 4)
            .merge(els)
            .attr('cx', d => x_scale(d.attack))
            .attr('cy', d => y_scale(d.defense))
            .attr('fill', 'steelblue')




        svg = d3.select("svg.pokemon_type");

        type_1 = d3.map(data, d=> d.type_1 );
        type_2 = d3.map(data, d=> d.type_2);

        console.log("Type 1",type_1);
        console.log("Type 2", type_2);

        type_dict = {'Normal': 0, 'Fire': 0, 'Fighting': 0,
                            'Water': 0, 'Flying': 0, 'Grass': 0,
                            'Poison': 0, 'Electric': 0, 'Ground': 0,
                            'Psychic': 0, 'Rock': 0, 'Ice': 0,
                            'Bug': 0, 'Dragon': 0, 'Ghost': 0,
                            'Dark': 0, 'Steel': 0, 'Fairy': 0}
        data.forEach( d=> {
          type_dict[d.type_1] += 1
          if (d.type_2 != null){
            type_dict[d.type_2] += 1
          }
        })
        console.log(type_dict);

        

        //const types = d3.map(type_dict);

        console.log(Object.keys(type_dict))

        const typeScale = d3.scaleBand().domain(type_1).range([0, CHART_WIDTH])
                            .padding(0.05);

        totalScale =d3.scaleLinear().domain([0,150]).range([CHART_HEIGHT, 0]);
        leftAxis = d3.axisLeft(totalScale).tickFormat("");
        leftGridlines = d3.axisLeft(totalScale)
                          .tickSize(-CHART_WIDTH-10)
                          .tickFormat("");

        bottomAxis = d3.axisBottom(typeScale);

        //axes.append('g').call(bottomAxis)
          //  .attr('transform', `translate(0,${CHART_HEIGHT})`);
        //axes.append('g').call(leftAxis)

        let annotations = svg.append("g").attr("id","annotations");
        let chartArea = svg.append("g").attr("id","points")
                .attr("transform",`translate(${margin.left},${margin.top})`);
        annotations.append("g")
                   .attr("class", "y axis")
                   .attr("transform",`translate(${margin.left-10},${margin.top})`)
                   .call(leftAxis)
        annotations.append("g")
                   .attr("class", "y gridlines")
                   .attr("transform",`translate(${margin.left-10},${margin.top})`)
                   .call(leftGridlines);
        // We're not making gridlines, since they'll just stick up from the bars
        annotations.append("g")
                   .attr("class", "x axis")
                   .attr("transform",`translate(${margin.left},${CHART_HEIGHT+margin.top+10})`)
                   .call(bottomAxis);


        chartArea.selectAll('rect.bar').data( data )
          .join('rect').attr('class','bar')
          .attr("fill",d=> type_color[d.type_1])
          .attr("x", d => typeScale(d.type_1))
          .attr("y", d => totalScale(type_dict[d.type_1]))
          .attr("height", d => totalScale(0) - totalScale(type_dict[d.type_1]))
          .attr("width", typeScale.bandwidth());

        //Do we want to add labels above the bars with the total number for each column??
        //Do we want to sort the columns to be in highest to lowest order?



    });

    </script>
    <script>
    </script>


</body>
</html>
